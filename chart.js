// Generated by CoffeeScript 1.3.3
(function() {
  var Chart,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Chart = (function() {

    function Chart() {
      this.restart = __bind(this.restart, this);

      this.redraw = __bind(this.redraw, this);

      this.recolor = __bind(this.recolor, this);

      this.prep_nodes = __bind(this.prep_nodes, this);

      this.foci_points = __bind(this.foci_points, this);

    }

    Chart.prototype.cols = 4;

    Chart.prototype.rows = 4;

    Chart.prototype.col_attr = 'type';

    Chart.prototype.row_attr = 'category';

    Chart.prototype.foci_points = function() {
      var points,
        _this = this;
      points = [];
      d3.range(this.cols).forEach(function(col) {
        var rows;
        rows = [];
        d3.range(_this.rows).forEach(function(row) {
          return rows.push({
            x: col * 250,
            y: row * 200
          });
        });
        return points.push(rows);
      });
      return points;
    };

    Chart.prototype.width = 1400;

    Chart.prototype.height = 720;

    Chart.prototype.fill = d3.scale.category20();

    Chart.prototype.data = null;

    Chart.prototype.nodes = null;

    Chart.prototype.cols_wrap = null;

    Chart.prototype.rows_wrap = null;

    Chart.prototype.color_index = function(data) {
      if (!this.types) {
        this.types = _.uniq(_.flatten(_.pluck(this.data, "type")));
      }
      return _.indexOf(this.types, data.type[0]);
    };

    Chart.prototype.draw_labels = function(col_titles, row_titles) {
      var foci,
        _this = this;
      foci = this.foci_points();
      this.vis.selectAll("text").remove();
      this.cols_wrap = this.vis;
      d3.range(this.cols).forEach(function(index) {
        return _this.cols_wrap.append("text").attr("x", (foci[index][0].x / 2.5) + 400).attr("y", (foci[index][0].y / 2.0) + 20).text(col_titles[index]);
      });
      this.rows_wrap = this.vis;
      return d3.range(this.rows).forEach(function(index) {
        return _this.rows_wrap.append("text").attr("x", foci[0][index].x + (foci[0][index].x / 2.0) + 20).attr("y", (foci[0][index].y / 2.5) + 200).text(row_titles[index]);
      });
    };

    Chart.prototype.prep_nodes = function() {
      var col_titles, count, row_titles,
        _this = this;
      col_titles = _.uniq(_.flatten(_.pluck(this.data, this.col_attr)));
      row_titles = _.uniq(_.flatten(_.pluck(this.data, this.row_attr)));
      this.cols = col_titles.length;
      this.rows = row_titles.length;
      this.draw_labels(col_titles, row_titles);
      if (!this.nodes) {
        this.nodes = [];
      }
      count = 0;
      this.data.forEach(function(data_node) {
        var columns_indexes, rows_indexes;
        columns_indexes = (_.intersection(data_node[_this.col_attr], col_titles)).map(function(title) {
          return _.indexOf(col_titles, title);
        });
        rows_indexes = (_.intersection(data_node[_this.row_attr], row_titles)).map(function(title) {
          return _.indexOf(row_titles, title);
        });
        return columns_indexes.forEach(function(col_index) {
          return rows_indexes.forEach(function(row_index) {
            var node;
            node = null;
            if (_this.nodes.length > count) {
              node = _this.nodes[count];
            }
            if (!node) {
              node = {};
              _this.nodes.push(node);
            }
            node.col = col_index;
            node.row = row_index;
            node.data = data_node;
            node.id = count;
            return count += 1;
          });
        });
      });
      if (this.nodes.length > count) {
        this.nodes.splice(count, this.nodes.length - count);
      }
      return this.nodes;
    };

    Chart.prototype.recolor = function() {
      var _this = this;
      return this.node.style("fill", function(d, i) {
        return _this.fill(_this.color_index(d.data));
      }).style("stroke", function(d, i) {
        return d3.rgb(_this.fill(_this.color_index(d.data))).darker(2);
      });
    };

    Chart.prototype.redraw = function() {
      var _this = this;
      this.node = this.vis.selectAll("circle.node").data(this.nodes, function(d) {
        return d.id;
      });
      this.node.enter().insert("svg:circle").attr("class", "node").attr("cx", function(d) {
        return d.x;
      }).attr("cy", function(d) {
        return d.y;
      }).attr("r", 8).style("stroke-width", 1.5).call(this.force.drag).on("mouseover", function(d) {
        var attrs,
          _this = this;
        d3.select("#desc").style('display', 'block');
        attrs = ["name", "site", "model", "category", "type", "price", "description", "extra"];
        return attrs.forEach(function(attr) {
          var val;
          val = d.data[attr];
          if ((typeof value) === "object") {
            val = val.join(", ");
          }
          d3.select("#desc #" + attr).text(val);
          if (attr === "site") {
            return d3.select("#desc #" + attr).attr("href", val);
          }
        });
      });
      this.node.exit().remove();
      return this.recolor();
    };

    Chart.prototype.restart = function() {
      this.force.stop();
      this.prep_nodes();
      this.redraw();
      return this.force.start();
    };

    Chart.prototype.init = function() {
      var _this = this;
      this.vis = d3.select("body").append("svg:svg").attr("width", this.width).attr("height", this.height);
      return d3.csv("food.csv", function(rows) {
        rows.forEach(function(row) {
          var list_cols;
          list_cols = ["model", "type", "category"];
          return list_cols.forEach(function(col_name) {
            if (row[col_name]) {
              return row[col_name] = row[col_name].split(",").map(function(word) {
                return word.trim();
              });
            }
          });
        });
        _this.data = rows;
        _this.prep_nodes();
        _this.force = d3.layout.force().nodes(_this.nodes).links([]).size([_this.width, _this.height]);
        _this.redraw();
        _this.force.on("tick", function(e) {
          var foci, k;
          foci = _this.foci_points();
          k = .05 * e.alpha;
          _this.nodes.forEach(function(o, i) {
            o.y += (foci[o.col][o.row].y - o.y) * k;
            return o.x += (foci[o.col][o.row].x - o.x) * k;
          });
          return _this.node.attr("cx", function(d) {
            return d.x;
          }).attr("cy", function(d) {
            return d.y;
          });
        });
        return _this.force.start();
      });
    };

    return Chart;

  })();

  window.chart = new Chart;

  chart.init();

}).call(this);
